/* Enclave.edl - PSI Enclave EDL file with Remote Attestation */

enclave {
    from "sgx_tkey_exchange.edl" import *;
    
    include "sgx_key_exchange.h"
    include "sgx_trts.h"
    
    trusted {
        /* Remote Attestation */
        public sgx_status_t enclave_init_ra(
            int b_pse,
            [out] sgx_ra_context_t *p_context);
        
        public sgx_status_t enclave_ra_close(
            sgx_ra_context_t context);
        
        public sgx_status_t verify_att_result_mac(
            sgx_ra_context_t context,
            [in,size=message_size] uint8_t* message,
            size_t message_size,
            [in,size=mac_size] uint8_t* mac,
            size_t mac_size);
        
        /* Get enclave measurement for verification */
        public sgx_status_t get_enclave_report(
            [in] const sgx_target_info_t* target_info,
            [out] sgx_report_t* report);
        
        /* Get session key for encryption */
        public sgx_status_t get_session_key(
            sgx_ra_context_t context,
            [out, size=16] uint8_t* sk_key);
        
        /* Encrypt PSI result using RA session key */
        public sgx_status_t encrypt_psi_result(
            sgx_ra_context_t context,
            [in, count=result_count] const uint32_t* result,
            uint32_t result_count,
            [out, size=encrypted_size] uint8_t* encrypted_data,
            uint32_t encrypted_size,
            [out, size=16] uint8_t* gcm_mac);
        
        /* Decrypt received data using RA session key */
        public sgx_status_t decrypt_client_data(
            sgx_ra_context_t context,
            [in, size=encrypted_size] const uint8_t* encrypted_data,
            uint32_t encrypted_size,
            [in, size=16] const uint8_t* gcm_mac,
            [out, count=10] uint32_t* decrypted_set,
            [out] uint32_t* set_size);
        
        /* Single client mode PSI */
        public sgx_status_t ecall_compute_psi_count(
            [in, count=5] const uint32_t* set1,
            [in, count=5] const uint32_t* set2,
            [out, count=5] uint32_t* result,
            [out] uint32_t* result_count);
        
        /* Multi-client mode PSI with RA context */
        public sgx_status_t ecall_register_client_set(
            uint32_t client_id,
            [in, count=10] const uint32_t* set,
            uint32_t set_size);
        
        public sgx_status_t ecall_compute_psi_multi(
            [out, count=10] uint32_t* result,
            [out] uint32_t* result_count);

        /* Enclave-to-Enclave Key Exchange (server side) */
        public sgx_status_t kx_server_init(
            uint32_t client_id,
            [out, size=64] uint8_t* server_pubkey);

        public sgx_status_t kx_server_finish(
            uint32_t client_id,
            [in, size=64] const uint8_t* client_pubkey);

        public sgx_status_t kx_encrypt_server(
            uint32_t client_id,
            [in, count=plain_count] const uint32_t* plaintext,
            uint32_t plain_count,
            [in, size=12] const uint8_t* iv,
            [out, size=cipher_size] uint8_t* ciphertext,
            uint32_t cipher_size,
            [out, size=16] uint8_t* gcm_tag);

        public sgx_status_t kx_decrypt_server(
            uint32_t client_id,
            [in, size=cipher_size] const uint8_t* ciphertext,
            uint32_t cipher_size,
            [in, size=12] const uint8_t* iv,
            [in, size=16] const uint8_t* gcm_tag,
            [out, count=plain_max] uint32_t* plaintext,
            uint32_t plain_max,
            [out] uint32_t* plain_count);
        
        /* Simple echo function for testing */
        public sgx_status_t ecall_echo(
            uint32_t client_id,
            [in, size=input_size] const uint8_t* input_data,
            uint32_t input_size,
            [out, size=1024] uint8_t* output_data,
            [out] uint32_t* output_size);
        
        /* Receiver request: fetch data from all registered servers and aggregate */
        public sgx_status_t ecall_receiver_request(
            uint32_t client_id,
            [out, size=4096] uint8_t* response_data,
            [out] uint32_t* response_size);
        
        /* Register a new data server */
        public sgx_status_t ecall_register_data_server(
            [in, string] const char* server_id);
    };
    
    untrusted {
        void ocall_print_string([in, string] const char *str);
        
        /* Send data to a registered data server over TLS */
        int ocall_send_encrypted(
            [in, string] const char* server_id,
            [in, size=data_size] const uint8_t* data,
            uint32_t data_size,
            [in, size=12] const uint8_t* iv,
            [in, size=16] const uint8_t* gcm_tag);

        /* Receive data from a registered data server over TLS */
        int ocall_recv_encrypted(
            [in, string] const char* server_id,
            [out, size=buffer_size] uint8_t* data,
            uint32_t buffer_size,
            [out, size=12] uint8_t* iv,
            [out, size=16] uint8_t* gcm_tag,
            [out] uint32_t* received_size);
    };
};
